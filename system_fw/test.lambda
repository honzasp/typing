id = /\a.\x:a.x.
const = /\a./\b.\x:b.\y:a.x.
not = \x:Bool.if x then false else true.

:a true.
:a not false.
:a id[Bool] true.
:a not (id[Bool] false).

Pair := \a.\b.\/r.(a->b->r)->r.
pair = /\a./\b.\x:a.\y:b.
  (/\r.\f:(a->b->r).f x y) as Pair a b.
fst = /\a./\b.\p:Pair a b.
  p [a] (\x:a.\y:b.x).
snd = /\a./\b.\p:Pair a b.
  p [b] (\x:a.\y:b.y).

:a fst[Bool][Bool] (pair[Bool][Bool] true false).
:a (snd[Bool][Bool->Bool] (pair[Bool][Bool->Bool] false not)) false.

Maybe := \a.\/r.(a->r)->r->r.
Either := \e.\a.\/r.(e->r)->(a->r)->r.

Monad_bind := \m::*->*. \/a.\/b. m a -> (a -> m b) -> m b.
Monad_return := \m::*->*. \/a. a -> m a.

just = /\a.\x:a.
  (/\r.\f:(a->r).\d:r.f x) as Maybe a.
nothing = /\a.
  (/\r.\f:(a->r).\d:r.d) as Maybe a.

bind_maybe = /\a./\b.
  \m:Maybe a. \f:a->Maybe b.
    m[Maybe b] (\x:a.f x) (nothing[b]).
return_maybe = just.

left = /\e./\a.\x:e.
  (/\r.\fl:(e->r).\fr:(a->r).fl x) as Either e a.
right = /\e./\a.\x:a.
  (/\r.\fl:(e->r).\fr:(a->r).fr x) as Either e a.

bind_either = /\e. /\a./\b.
  \m:Either e a. \f:a->Either e b.
    m[Either e b] (\lt:e.left[e][b] lt) (\rt:a. f rt).
return_either = right.

:a (just[Bool] false)[Bool] not false.
:a (nothing[Bool])[Bool] (id[Bool]) true.

:a (left[Bool][Unit] false)[Bool] (not) (const[Unit][Bool] false).
:a (right[Unit][Unit] unit)[Bool]
  (const[Unit][Bool] false)
  (const[Unit][Bool] true).

rcd1 = {x=true,y=not}.
:a rcd1#x.
:a rcd1#y false.

and = \x:Bool.\y:Bool. if x then y else false.
or = \x:Bool.\y:Bool. if x then true else y.

Monoid := \m.
  { mempty = m
  , mappend = m->m->m
  }.

Monoid_Bool_and =
  { mempty = true
  , mappend = and
  } as Monoid Bool.

Monoid_Bool_or =
  { mempty = false
  , mappend = or
  } as Monoid Bool.

mdouble = /\m.\monoid:Monoid m.
  \x:m. monoid#mappend x x.
